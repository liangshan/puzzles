## 长城以外
> Across the Great Wall, we can reach every corner in the world

由于众所周知的原因，我们的网站需要过滤屏蔽词。我们的屏蔽词库大约有3万个，如何实现就是一个难题，相信大家也很好奇我们是怎么做到每分钟处理集团超过20万次的屏蔽词过滤需求。

把这个问题抽象一下：
```
给定一个词库A，每当传入一个字符串B，返回B包含了A中的哪些词
```

先给一个不适用的答案，时间复杂度O(m * n):
```
for (word in A) {
    if (word is part of B) {
        result.append(word)
    }    
}
```

### 解答
这是一个较为典型的 **字符串多模式匹配问题** ，总体思路是先将词库预处理为某种数据结构，让查询时间复杂度仅和查询字符串B有关。

解决问题的关键在于 [有限自动机](http://zh.wikipedia.org/wiki/%E8%87%AA%E5%8A%A8%E6%9C%BA) 。

我们使用的 [Aho-Corasick](http://blog.csdn.net/sealyao/article/details/4560427) 算法是其中较为高效的一个实现。

整个算法中，最重要的部分有三个：

1. 转向函数，即状态机各状态的转换关系
2. 失效函数，当前状态无匹配时的转换关系
3. 输出函数，匹配某状态时需要打印的模式串

在预处理过程中，构造上述三种函数需要遍历一次词库A，时间复杂度为O(m)。而每次查询的时间复杂度为O(n)，仅与传入的字符串长度有关。

这也是为什么MSS服务可以在每分钟20万次请求下，仍然可以保持5ms以下的单次计算时间。



